{"ast":null,"code":"import { makeCamelCaseArray, makeCamelCase } from './Utils';\n\nfunction getBoundingBox(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCase(geometry.BoundingBox);\n}\n\nfunction getPolygon(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCaseArray(geometry.Polygon);\n}\n/**\n * Organizes blocks from Rekognition API to each of the categories and and structures\n * their data accordingly.\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\n\n\nexport function categorizeRekognitionBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  }; // We categorize each block by running a forEach loop through them.\n\n  blocks.forEach(function (block) {\n    switch (block.Type) {\n      case 'LINE':\n        response.text.lines.push(block.DetectedText);\n        response.text.linesDetailed.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: null\n        });\n        break;\n\n      case 'WORD':\n        response.text.fullText += block.DetectedText + ' ';\n        response.text.words.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        break;\n    }\n  }); // remove trailing space of fullText\n\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n  return response;\n}\n/**\n * Organizes blocks from Textract API to each of the categories and and structures\n * their data accordingly.\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\n\nexport function categorizeTextractBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  }; // if blocks is an empty array, ie. textract did not detect anything, return empty response.\n\n  if (blocks.length === 0) return response;\n  /**\n   * We categorize each of the blocks by running a forEach loop through them.\n   *\n   * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\n   * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\n   * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\n   *\n   * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\n   * block except the Page block.\n   */\n\n  var tableBlocks = Array();\n  var keyValueBlocks = Array();\n  var blockMap = {};\n  blocks.forEach(function (block) {\n    switch (block.BlockType) {\n      case 'LINE':\n        response.text.lines.push(block.Text);\n        response.text.linesDetailed.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: block.Page\n        });\n        break;\n\n      case 'WORD':\n        response.text.fullText += block.Text + ' ';\n        response.text.words.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n\n      case 'SELECTION_ELEMENT':\n        var selectionStatus = block.SelectionStatus === 'SELECTED' ? true : false;\n        if (!response.text.selections) response.text.selections = [];\n        response.text.selections.push({\n          selected: selectionStatus,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n\n      case 'TABLE':\n        tableBlocks.push(block);\n        break;\n\n      case 'KEY_VALUE_SET':\n        keyValueBlocks.push(block);\n        blockMap[block.Id] = block;\n        break;\n\n      default:\n        blockMap[block.Id] = block;\n    }\n  }); // remove trailing space in fullText\n\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1); // Post-process complex structures if they exist.\n\n  if (tableBlocks.length !== 0) {\n    var tableResponse_1 = Array();\n    tableBlocks.forEach(function (table) {\n      tableResponse_1.push(constructTable(table, blockMap));\n    });\n    response.text.tables = tableResponse_1;\n  }\n\n  if (keyValueBlocks.length !== 0) {\n    var keyValueResponse_1 = Array();\n    keyValueBlocks.forEach(function (keyValue) {\n      // We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n      if (keyValue.EntityTypes.indexOf('KEY') !== -1) {\n        keyValueResponse_1.push(constructKeyValue(keyValue, blockMap));\n      }\n    });\n    response.text.keyValues = keyValueResponse_1;\n  }\n\n  return response;\n}\n/**\n * Constructs a table object using data from its children cells.\n * @param {Textract.Block} table - Table block that has references (`Relationships`) to its cells\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\n\nexport function constructTable(table, blockMap) {\n  var tableMatrix;\n  tableMatrix = []; // visit each of the cell associated with the table's relationship.\n\n  table.Relationships.forEach(function (tableRelation) {\n    tableRelation.Ids.forEach(function (cellId) {\n      var cellBlock = blockMap[cellId];\n      var row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n\n      var col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n      // extract data contained inside the cell.\n\n      var content = extractContentsFromBlock(cellBlock, blockMap);\n      var cell = {\n        text: content.text,\n        boundingBox: getBoundingBox(cellBlock.Geometry),\n        polygon: getPolygon(cellBlock.Geometry),\n        selected: content.selected,\n        rowSpan: cellBlock.RowSpan,\n        columnSpan: cellBlock.ColumnSpan\n      };\n      if (!tableMatrix[row]) tableMatrix[row] = [];\n      tableMatrix[row][col] = cell;\n    });\n  });\n  var rowSize = tableMatrix.length;\n  var columnSize = tableMatrix[0].length; // Note that we leave spanned cells undefined for distinction\n\n  return {\n    size: {\n      rows: rowSize,\n      columns: columnSize\n    },\n    table: tableMatrix,\n    boundingBox: getBoundingBox(table.Geometry),\n    polygon: getPolygon(table.Geometry)\n  };\n}\n/**\n * Constructs a key value object from its children key and value blocks.\n * @param {Textract.Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\n\nexport function constructKeyValue(keyBlock, blockMap) {\n  var keyText = '';\n  var valueText = '';\n  var valueSelected;\n  keyBlock.Relationships.forEach(function (keyValueRelation) {\n    if (keyValueRelation.Type === 'CHILD') {\n      // relation refers to key\n      var contents = extractContentsFromBlock(keyBlock, blockMap);\n      keyText = contents.text;\n    } else if (keyValueRelation.Type === 'VALUE') {\n      // relation refers to value\n      keyValueRelation.Ids.forEach(function (valueId) {\n        var valueBlock = blockMap[valueId];\n        var contents = extractContentsFromBlock(valueBlock, blockMap);\n        valueText = contents.text;\n        if (contents.selected != null) valueSelected = contents.selected;\n      });\n    }\n  });\n  return {\n    key: keyText,\n    value: {\n      text: valueText,\n      selected: valueSelected\n    },\n    polygon: getPolygon(keyBlock.Geometry),\n    boundingBox: getBoundingBox(keyBlock.Geometry)\n  };\n}\n/**\n * Extracts text and selection from input block's children.\n * @param {Textract.Block}} block - Block that we want to extract contents from.\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\n\nexport function extractContentsFromBlock(block, blockMap) {\n  var words = '';\n  var isSelected;\n\n  if (!block.Relationships) {\n    // some block might have no content\n    return {\n      text: '',\n      selected: undefined\n    };\n  }\n\n  block.Relationships.forEach(function (relation) {\n    relation.Ids.forEach(function (contentId) {\n      var contentBlock = blockMap[contentId];\n\n      if (contentBlock.BlockType === 'WORD') {\n        words += contentBlock.Text + ' ';\n      } else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n        isSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n      }\n    });\n  });\n  words = words.substr(0, words.length - 1); // remove trailing space.\n\n  return {\n    text: words,\n    selected: isSelected\n  };\n}","map":{"version":3,"mappings":"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","names":["makeCamelCaseArray","makeCamelCase","getBoundingBox","geometry","undefined","BoundingBox","getPolygon","Polygon","categorizeRekognitionBlocks","blocks","response","text","fullText","words","lines","linesDetailed","forEach","block","Type","push","DetectedText","polygon","Geometry","boundingBox","page","substr","length","categorizeTextractBlocks","tableBlocks","Array","keyValueBlocks","blockMap","BlockType","Text","Page","Id","selectionStatus","SelectionStatus","selections","selected","tableResponse_1","constructTable","table","tables","keyValueResponse_1","keyValue","EntityTypes","indexOf","constructKeyValue","keyValues","tableMatrix","Relationships","tableRelation","Ids","cellBlock","cellId","row","RowIndex","col","ColumnIndex","content","extractContentsFromBlock","cell","rowSpan","RowSpan","columnSpan","ColumnSpan","rowSize","columnSize","size","rows","columns","keyBlock","keyText","valueText","valueSelected","keyValueRelation","contents","valueBlock","valueId","key","value","isSelected","relation","contentBlock","contentId"],"sourceRoot":"","sources":["../../src/Providers/IdentifyTextUtils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}